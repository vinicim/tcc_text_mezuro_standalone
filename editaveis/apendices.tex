\lstdefinelanguage{JavaScript}{
  keywords={typeof, new, true, false, catch, function, return, null, catch, switch, var, if, in, while, do, else, case, break},
  keywordstyle=\color{blue}\bfseries,
  ndkeywords={class, export, boolean, throw, implements, import, this},
  ndkeywordstyle=\color{darkgray}\bfseries,
  identifierstyle=\color{black},
  sensitive=false,
  comment=[l]{//},
  morecomment=[s]{/*}{*/},
  commentstyle=\color{purple}\ttfamily,
  stringstyle=\color{red}\ttfamily,
  morestring=[b]',
  morestring=[b]"
}

\lstset{
   language=JavaScript,
   backgroundcolor=\color{lightgray},
   extendedchars=true,
   basicstyle=\footnotesize\ttfamily,
   showstringspaces=false,
   showspaces=false,
   numbers=left,
   numberstyle=\footnotesize,
   numbersep=9pt,
   tabsize=2,
   breaklines=true,
   showtabs=false,
   captionpos=b
}


\newpage
\appendix
\section{Questionário} 
\label{form-pesquisa}

\textbf{{\large Evolução da Plataforma Mezuro}}

\begin{mdframed}
Esta é uma pesquisa relacionada à evolução do Mezuro. Direcionada aos colaboradores dessa plataforma, ela tem como objetivo extrair informações, que serão utilizadas no trabalho de conclusão de curso do aluno Vinícius Vieira, sob orientação do professor Paulo Meirelles.
\end{mdframed}

\begin{enumerate}
\item Quais os principais problemas, do ponto de vista do código e da arquitetura, do antigo Mezuro? Por que os mantenedores decidiram escrevê-lo do zero? *
\item Há aspectos do código ou da arquitetura anteriores melhores que do novo código, ou vice-versa? Quais são eles? *
\item Em relação ao código antigo, o novo código fornece (ou está previsto): *
  \begin{enumerate}
  \item As mesmas funcionalidades
  \item Menos funcionalidades
  \item Mais funcionalidades 
  \end{enumerate}
\item Em relação a questão anterior. Em caso de mais funcionalidades ou menos, quais são elas? 
\end{enumerate}

\newpage
\section{Respostas}
\label{resp-pesquisa}

{\large Respostas do Questionário}

\textbf{Respostas 1}

\begin{enumerate}
\item Quais os principais problemas, do ponto de vista do código e da arquitetura, do antigo Mezuro? Por que os mantenedores decidiram escrevê-lo do zero? *
  \begin{mdframed}
A arquitetura de plugins do Noosfero impõe limitações para a estrutura da aplicação, como rotas e também herança de controllers por exemplo. Além disso o problema com tecnologias obsoletas era sério. Ruby 1.8, além de já não receber suporte dos desenvolvedores há algum tempo, tem sérios problemas de performance corrigidos nas versões posteriores. Da mesma forma, a versão 2 do Rails é incompatível com boa parte das gemas atuais.
  \end{mdframed}
%----------------------------------------------------------------------
\item Há aspectos do código ou da arquitetura anteriores melhores que do novo código, ou vice-versa? Quais são eles? *
  \begin{mdframed}
Em suma, o novo código é melhor por que resolvemos todos os problemas da resposta anterior.
  \end{mdframed}
%---------------------------------------------------------------------
\item Em relação ao código antigo, o novo código fornece (ou está previsto): *
  \begin{enumerate}
  \item As mesmas funcionalidades
  \item Menos funcionalidades
  \item Mais funcionalidades 
  \end{enumerate}
    \begin{mdframed}
    As mesmas funcionalidades, menos funcionalidades, mais funcionalidades
    \end{mdframed}
%----------------------------------------------------------------------
\item Em relação a questão anterior. Em caso de mais funcionalidades ou menos, quais são elas? 
  \begin{mdframed}
As novas funcionalidades que temos previstas além das que já existiam estão todas descritas nas issues do github.A menos, não pretendemos fornercer uma rede social com páginas pessoais, muito menos comunidades nem suporte a temas.
  \end{mdframed}
\end{enumerate}

\textbf{Respostas 2}

\begin{enumerate}
\item Quais os principais problemas, do ponto de vista do código e da arquitetura, do antigo Mezuro? Por que os mantenedores decidiram escrevê-lo do zero? *
  \begin{mdframed}
Por antes o Mezuro ser um plugin de um software maior, nossa arquitetura era limitada ao que este software permitia fazer. Sobre o código, éramos obrigados a usar versões antigas de bibliotecas, o que fazia com que nossas soluções ficarem atrasadas com relação com o que está sendo desenvolvido no mundo do Ruby on Rails.
Por esses motivos, resolvemos escrever o código do zero, pois agora temos liberdade para mudar a arquitetura sempre que necessário e podemos usar as tecnologias mais novas.
  \end{mdframed}
%----------------------------------------------------------------------
\item Há aspectos do código ou da arquitetura anteriores melhores que do novo código, ou vice-versa? Quais são eles? *
  \begin{mdframed}
Antes o Mezuro era um plugin de um sistema maior, portanto a arquitetura era de um plugin e não de uma aplicação rails completa. No novo código, podemos desfrutar de todas as vantagens que o rails fornece. Por outro lado, antes tínhamos muita coisa já implementada que agora temos que refazer.
  \end{mdframed}
%---------------------------------------------------------------------
\item Em relação ao código antigo, o novo código fornece (ou está previsto): *
  \begin{enumerate}
  \item As mesmas funcionalidades
  \item Menos funcionalidades
  \item Mais funcionalidades 
  \end{enumerate}
    \begin{mdframed}
As mesmas funcionalidades, mais funcionalidades
    \end{mdframed}
%----------------------------------------------------------------------
\item Em relação a questão anterior. Em caso de mais funcionalidades ou menos, quais são elas? 
  \begin{mdframed}
Ampliar o escopo para analisar código Ruby, melhorar a visualização dos gráficos e dos resultados, notificação de alerta quando uma métrica atingir certo valor considerado ruim, entre outras.
  \end{mdframed}
\end{enumerate}

\newpage
\section{Código-Fonte}
\label{source-code-appendix}

\subsection{Feature Repositórios}
\subsubsection{\textit{Controller}}
\begin{lstlisting}[language=Ruby]
include OwnershipAuthentication

class RepositoriesController < ApplicationController
  before_action :authenticate_user!, except: [:show, :state]
  before_action :project_owner?, only: [:new, :create]
  before_action :repository_owner?, only: [:edit, :update, :destroy, :process_repository]
  before_action :set_repository, only: [:show, :edit, :update, :destroy, :state, :process_repository]

  # GET /projects/1/repositories/1
  # GET /projects/1/repositories/1.json
  # GET /projects/1/repositories/1/modules/1
  # GET /projects/1/repositories/1/modules/1.json
  def show
    set_configuration
  end

  # GET projects/1/repositories/new
  def new
    @project_id = params[:project_id]
    @repository = Repository.new
    @repository_types = Repository.repository_types
  end

  # GET /repositories/1/edit
  def edit
    @project_id = params[:project_id]
    @repository_types = Repository.repository_types
  end

  # POST /projects/1/repositories
  # POST /projects/1/repositories.json
  def create
    @repository = Repository.new(repository_params)
    @repository.project_id = params[:project_id]
    respond_to do |format|
      create_and_redir(format)
    end
  end

  # PUT /projects/1/repositories/1
  # PUT /projects/1/repositories/1.json
  def update
    respond_to do |format|
      if @repository.update(repository_params)
        format.html { redirect_to(project_repository_path(params[:project_id], @repository.id), notice: 'Repository was successfully updated.') }
        format.json { head :no_content }
      else
        failed_action(format, 'edit')
      end
    end
  end

  # DELETE /projects/1/repositories/1
  # DELETE /projects/1/repositories/1.json
  def destroy
    @repository.destroy
    respond_to do |format|
      format.html { redirect_to project_path(params[:project_id]) }
      format.json { head :no_content }
    end
  end

  # POST /projects/1/repositories/1/state
  def state
    if params[:last_state] != 'READY'
      if params[:day].nil?
        @processing = @repository.last_processing
      else
        year, month, day = params[:year], params[:month], params[:day]
        @processing = Processing.processing_with_date_of(@repository.id, "#{year}-#{month}-#{day}")
      end

      respond_to do |format|
        if @processing.nil?
          format.js { render action: 'unprocessed' }
        elsif @processing.state == 'READY'
          format.js { render action: 'load_ready_processing' }
        else
          format.js { render action: 'reload_processing' }
        end
      end
    else
      head :ok, :content_type => 'text/html' # Just don't do anything
    end
  end

  # GET /projects/1/repositories/1/process
  def process_repository
    @repository.process
    set_configuration
    respond_to do |format|
      format.html { redirect_to project_repository_path(@repository.project_id, @repository.id) }
    end
  end

private
  # Duplicated code on create and update actions extracted here
  def failed_action(format, destiny_action)
    @project_id = params[:project_id]
    @repository_types = Repository.repository_types

    format.html { render action: destiny_action }
    format.json { render json: @repository.errors, status: :unprocessable_entity }
  end

  # Use callbacks to share common setup or constraints between actions.
  def set_repository
    @repository = Repository.find(params[:id].to_i)
  end

  def set_configuration
    @configuration = MezuroConfiguration.find(@repository.configuration_id)
  end

  # Never trust parameters from the scary internet, only allow the white list through.
  def repository_params
    params[:repository]
  end

  # Code extracted from create action
  def create_and_redir(format)
    if @repository.save
      format.html { redirect_to project_repository_process_path(@repository.project_id, @repository.id), notice: 'Repository was successfully created.' }
    else
      failed_action(format, 'new')
    end
  end

end
\end{lstlisting}

%\subsubsection{\textit{Model}}
%ass Repository < KalibroGatekeeperClient::Entities::Repository
%	include KalibroRecord
%
%  validates :name, presence: true, kalibro_uniqueness: true
%  validates :address, presence: true
%
%  def last_processing
%    if Processing.has_processing(@id)
%      Processing.processing_of(@id)
%    else
%      nil
%    end
%  end
%end
%
%\end{lstlisting}
%\begin{lstlisting}[language=Ruby]
%class Repository < KalibroGatekeeperClient::Entities::Repository
%	include KalibroRecord
%
%  validates :name, presence: true, kalibro_uniqueness: true
%  validates :address, presence: true
%
%  def last_processing
%    if Processing.has_processing(@id)
%      Processing.processing_of(@id)
%    else
%      nil
%    end
%  end
%end
%\end{lstlisting}

\subsection{Feature Configuration}
\subsubsection{\textit{Controller}}
\begin{lstlisting}[language=Ruby]
class MetricConfigurationsController < BaseMetricConfigurationsController
  def choose_metric
    @mezuro_configuration_id = params[:mezuro_configuration_id].to_i
    @metric_configuration_id = params[:metric_configuration_id].to_i
    @base_tools = KalibroGatekeeperClient::Entities::BaseTool.all
    @exist_metric = params[:exist_metric]
  end

  def new
    super
    @metric_configuration = MetricConfiguration.new
    @metric_configuration.configuration_id = params[:mezuro_configuration_id].to_i
    @metric_configuration.base_tool_name = params[:base_tool_name]
  end

  def create
    @configuration_metrics = params[:configuration_metrics_names]
    
    @configuration_metrics.each do |configuration_metric|
      code = automatic_code configuration_metric
      @metric_configuration = MetricConfiguration.new
      @metric_configuration.configuration_id = params[:mezuro_configuration_id].to_i
      @metric_configuration.base_tool_name = "Analizo"
      @metric_configuration.metric = KalibroGatekeeperClient::Entities::BaseTool.find_by_name("Analizo").metric(configuration_metric.to_s)
      @metric_configuration.code = code.to_s
      @metric_configuration.weight = "0"
      @metric_configuration.aggregation_form = "AVERAGE"
      @metric_configuration.reading_group_id = 1
      @metric_configuration.save
    end
    respond_to do |format|
      create_and_redir(format)
    end    
  end

  def automatic_code(metric_name)
    array = metric_name.split(" ", 3);
    automatic_code = ""
    array.each do |metric_word|
      automatic_code = automatic_code << metric_word[0...2]
    end
    automatic_code
  end

  def edit
    #FIXME: set the configuration id just once!
    @mezuro_configuration_id = params[:mezuro_configuration_id]
    @metric_configuration.configuration_id = @mezuro_configuration_id
  end

  def update
    puts '=' * 100
    puts 'I reached the action controller!'
    respond_to do |format|
      @metric_configuration.configuration_id = params[:mezuro_configuration_id]
      if @metric_configuration.update(metric_configuration_params)
        format.html { redirect_to(mezuro_configuration_path(@metric_configuration.configuration_id), notice: 'Metric Configuration was successfully updated.') }
        format.json { head :no_content }
      else
        failed_action(format, 'edit')
      end
    end
  end

  def destroy
    @metric_configuration.destroy
    respond_to do |format|
      format.html { redirect_to mezuro_configuration_path(params[:mezuro_configuration_id]) }
      format.json { head :no_content }
    end
  end

  protected

  def metric_configuration
    @metric_configuration
  end

  def update_metric_configuration (new_metric_configuration)
    @metric_configuration = new_metric_configuration
  end

  private

  # Duplicated code on create and update actions extracted here
  def failed_action(format, destiny_action)
    @mezuro_configuration_id = params[:mezuro_configuration_id]

    format.html { render action: destiny_action }
    format.json { render json: @metric_configuration.errors, status: :unprocessable_entity }
  end

  #Code extracted from create action
  def create_and_redir(format)
    if @metric_configuration.save
      format.html { redirect_to mezuro_configuration_path(@metric_configuration.configuration_id), notice: 'Metric Configuration was successfully created.' }
    else
      failed_action(format, 'new')
    end
  end
end

\end{lstlisting}

%\subsubsection{\textit{Model}}
%\begin{lstlisting}[language=Ruby]
%require "validators/kalibro_uniqueness_validator.rb"
%
%class MezuroConfiguration < KalibroGatekeeperClient::Entities::Configuration
%  include KalibroRecord
%
%  attr_accessor :name
%  validates :name, presence: true, kalibro_uniqueness: true
%
%  def metric_configurations
%    MetricConfiguration.metric_configurations_of(self.id)
%  end
%end
%\end{lstlisting}


\begin{lstlisting}
include OwnershipAuthentication

class MezuroConfigurationsController < ApplicationController
  before_action :authenticate_user!, except: [:index, :show]
  before_action :mezuro_configuration_owner?, only: [:edit, :update, :destroy]

  # GET /mezuro_configurations/new
  def new
    @mezuro_configuration = MezuroConfiguration.new
  end

  # GET /mezuro_configurations
  # GET /mezuro_configurations.json
  def index
    @mezuro_configurations = MezuroConfiguration.all
  end

  # POST /mezuro_configurations
  # POST /mezuro_configurations.json
  def create
    @mezuro_configuration = MezuroConfiguration.new(mezuro_configuration_params)
    respond_to do |format|
      create_and_redir(format)
    end
  end

  # GET /mezuro_configurations/1
  # GET /mezuro_configurations/1.json
  def show
    set_mezuro_configuration
    @mezuro_configuration_metric_configurations = @mezuro_configuration.metric_configurations
  end

  # GET /mezuro_configurations/1/edit
  # GET /mezuro_configurations/1/edit.json
  def edit
    set_mezuro_configuration
  end


  def update
    set_mezuro_configuration
    if @mezuro_configuration.update(mezuro_configuration_params)
      redirect_to(mezuro_configuration_path(@mezuro_configuration.id))
    else
      render "edit"
    end
  end

  # DELETE /mezuro_configurations/1
  # DELETE /mezuro_configurations/1.json
  def destroy
    set_mezuro_configuration
    current_user.mezuro_configuration_ownerships.find_by_mezuro_configuration_id(@mezuro_configuration.id).destroy
    @mezuro_configuration.destroy
    respond_to do |format|
      format.html { redirect_to mezuro_configurations_url }
      format.json { head :no_content }
    end
  end

  private
  # Use callbacks to share common setup or constraints between actions.
  def set_mezuro_configuration
    @mezuro_configuration = MezuroConfiguration.find(params[:id])
  end

  # Never trust parameters from the scary internet, only allow the white list through.
  def mezuro_configuration_params
    params[:mezuro_configuration]
  end

  # Extracted code from create action
  def create_and_redir(format)
    if @mezuro_configuration.save
      current_user.mezuro_configuration_ownerships.create mezuro_configuration_id: @mezuro_configuration.id

      format.html { redirect_to mezuro_configuration_path(@mezuro_configuration.id), notice: 'mezuro configuration was successfully created.' }
      format.json { render action: 'show', status: :created, location: @mezuro_configuration }
    else
      format.html { render action: 'new' }
      format.json { render json: @mezuro_configuration.errors, status: :unprocessable_entity }
    end
  end
end

\end{lstlisting}

\subsection{Gráfico Radar}
Nesta subseção se encontra o código-fonte referente a aplicação da técnica de visualização do Radar. O script abaixo encontra-se na \textit{view} \textit{show.html} da entidade \textit{Repository}, a qual é responsável pela abertura do \textit{modal}, que é a estrutura visual gerada, por cima da \textit{view} principal, para apresentar o gráfico.

\begin{lstlisting}

<script type="text/javascript">

$('#my-modal').on('show', function () {

    $(this).find('.modal-body').css({
      width:'auto',
      height:'auto', 
      'max-height':'100%'});
});

var w = 500,
h = 500;

var colorscale = d3.scale.category10();

//Data
var myData = new Array([]);

d3.tsv("/data.tsv", type, function(error, data) {
  
  for (var i = 0; i < data.length; i++) { 
    var map = {};
    map["axis"] = data[i].axis;
    map["value"] = data[i].value;   
    myData[0][i] = map;
  }
  console.log(myData[0]);

  //Call function to draw the Radar chart
  RadarChart.draw("#chart", myData, mycfg);
});

function type(d) {
  d.value = +d.value; // coerce to number
  return d;
}

//Options for the Radar chart, other than default
var mycfg = {
  w: w,
  h: h,
  maxValue: 150,
  levels: 5,
  ExtraWidthX: 200
}

</script>

\end{lstlisting}

O código abaixo é referente a estrutura que contem o gráfico, o chamado \textit{modal}.

\begin{lstlisting}
<div class="modal hide fade" id="my-modal" title="Radar Chart">
  <div class="modal-header">
    <button aria-hidden="true" class="close" data-dismiss="modal" type="button">x</button>
    <h3 id="myModalLabel">Visualization</h3>
  </div>
  <div class="modal-body" id="chart">
    <h4>Radar Chart</h4>
  </div>
  <div class="modal-footer">
    <button aria-hidden="true" class="btn" data-dismiss="modal">Close</button>
  </div>
</div>
\end{lstlisting}

\begin{lstlisting}
<%= link_to "Visualize", "#my-modal", :class => "btn", "data-toggle" => "modal" %>
\end{lstlisting}

\subsection{CSS formwithtooltip}
\label{css-form}

\begin{lstlisting}
.form-table {
  margin: 0 !important;
  background: #fff;
  -webkit-box-shadow: 0 1px 2px rgba(0, 0, 0, 0.075);
  box-shadow: 0 1px 2px rgba(0, 0, 0, 0.075);
}

.form-row {
  float: left;
  width: 100%;
  border-bottom: 1px solid #f2f2f2;
  border-top: 1px solid #e3e3e3;
  display: inline-flex;
}

.field-container {
  position: relative;
  float: left;
  width: 653px;
  padding: 20px;
}

.help-container {
  float: left;
  width: 400px;
  padding: 20px;
  background: #f5f5f5;
  border-left: 1px solid #e3e3e3;
  border-right: 1px solid #e3e3e3;
}

.text-field {
  width: 95% !important;
  margin: 0;
  background: #f9f9f9;
}

.text-area {
  width: 95% !important;
  margin: 0;
}

.field-container select {
  width: 99% !important;
  margin: 0;
}
\end{lstlisting}
